{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"技巧\" tag",
    "description": "欢迎来到Huan的笔记空间~~~~~~🌸",
    "home_page_url": "https://yhuanhuan01.github.io",
    "items": [
        {
            "id": "https://yhuanhuan01.github.io/2024/07/03/Dockerfile%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/",
            "url": "https://yhuanhuan01.github.io/2024/07/03/Dockerfile%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83/",
            "title": "Dockerfile书写规范",
            "date_published": "2024-07-03T02:19:52.000Z",
            "content_html": "<h1 id=\"dockerfile书写规范\"><a class=\"markdownIt-Anchor\" href=\"#dockerfile书写规范\">#</a> Dockerfile 书写规范</h1>\n<blockquote>\n<p>dockerfile 书写目的</p>\n</blockquote>\n<p>尽量构建的镜像尽可能小，提高部署速度，提高效率。</p>\n<blockquote>\n<p>dockerfile 书写格式</p>\n</blockquote>\n<h4 id=\"from\"><a class=\"markdownIt-Anchor\" href=\"#from\">#</a> FROM</h4>\n<p>指定基础镜像，若想去搭建 ubuntu22.04 镜像。则格式应为下面</p>\n<blockquote>\n<p>FROM ubuntu:22.04</p>\n</blockquote>\n<h4 id=\"run\"><a class=\"markdownIt-Anchor\" href=\"#run\">#</a> RUN</h4>\n<blockquote>\n<p>在镜像中执行命令，通常用于安装软件或配置环境。</p>\n</blockquote>\n<h4 id=\"cmd\"><a class=\"markdownIt-Anchor\" href=\"#cmd\">#</a> CMD</h4>\n<blockquote>\n<p>容器启动时执行的命令。通常写入 <code>.sh</code>  文件内</p>\n</blockquote>\n<h4 id=\"label\"><a class=\"markdownIt-Anchor\" href=\"#label\">#</a> LABEL</h4>\n<blockquote>\n<p>为镜像添加元数据标签。</p>\n</blockquote>\n<h4 id=\"env\"><a class=\"markdownIt-Anchor\" href=\"#env\">#</a> ENV</h4>\n<blockquote>\n<p>设置环境变量。</p>\n</blockquote>\n<h4 id=\"copy\"><a class=\"markdownIt-Anchor\" href=\"#copy\">#</a> COPY</h4>\n<blockquote>\n<p>将本地文件或目录复制到镜像中。</p>\n<p>如果想要持久保留化，配合 RUN cp filename 保留在容器内，否则 COPY 完之后，开启容器是就会自动销毁</p>\n</blockquote>\n<h4 id=\"add\"><a class=\"markdownIt-Anchor\" href=\"#add\">#</a> ADD</h4>\n<blockquote>\n<p>类似于 COPY，但支持从 URL 下载文件。</p>\n</blockquote>\n<h4 id=\"volume\"><a class=\"markdownIt-Anchor\" href=\"#volume\">#</a> VOLUME</h4>\n<blockquote>\n<p>创建一个挂载点，用于数据持久化。</p>\n</blockquote>\n<h4 id=\"expose\"><a class=\"markdownIt-Anchor\" href=\"#expose\">#</a> EXPOSE</h4>\n<blockquote>\n<p>指定容器运行时监听的端口。</p>\n</blockquote>\n<h4 id=\"workdir\"><a class=\"markdownIt-Anchor\" href=\"#workdir\">#</a> WORKDIR</h4>\n<blockquote>\n<p>设置容器的工作目录。</p>\n</blockquote>\n",
            "tags": [
                "技巧"
            ]
        },
        {
            "id": "https://yhuanhuan01.github.io/2024/06/27/%E5%85%B3%E4%BA%8E%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BF%99%E4%BB%B6%E4%BA%8B2/",
            "url": "https://yhuanhuan01.github.io/2024/06/27/%E5%85%B3%E4%BA%8E%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BF%99%E4%BB%B6%E4%BA%8B2/",
            "title": "关于恢复符号表这件事2",
            "date_published": "2024-06-27T10:35:30.000Z",
            "content_html": "<h1 id=\"关于恢复符号表这件事2\"><a class=\"markdownIt-Anchor\" href=\"#关于恢复符号表这件事2\">#</a> 关于恢复符号表这件事 2</h1>\n<p>前言</p>\n<blockquote>\n<p>由于 rizzo 恢复符号表真滴一言难尽，于是重拾之前如何恢复符号表这个任务</p>\n</blockquote>\n<p>在这个阶段，鄙人确实找到了一个办法去进行符号表恢复</p>\n<p>使用 FLAIR，由于网上的资料晦涩难懂，于是鄙人打算亲自写一篇去自己去理解</p>\n<h2 id=\"flair\"><a class=\"markdownIt-Anchor\" href=\"#flair\">#</a> FLAIR</h2>\n<blockquote>\n<p>flair 通过对库文件中的函数生成签名，并生成对应的签名文件，然后和程序中的函数进行签名匹配找到匹配的函数来帮助我们还原库函数。</p>\n</blockquote>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627180330677.png\" alt=\"image-20240627180330677\"></p>\n<p>这是此项目需要用到的 linux 文件，因为鄙人习惯使用 linux 系统，所以会用 linux 系统下的 elf 文件用法去讲解</p>\n<p>先给出一篇网上的<span class=\"exturl\" data-url=\"aHR0cHM6Ly94ei5hbGl5dW4uY29tL3QvNDQ4ND90aW1lX18xMzExPW40JTJCeG5EMEQ5RGdEdUQwMkJpRCUyRmplMCUzRGVJb3ZhaVFEbXhSckQmYW1wO2FsaWNobGdyZWY9aHR0cHMlM0ElMkYlMkZ3d3cuZ29vZ2xlLmNvbSUyRg==\">文章</span></p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627180549231.png\" alt=\"image-20240627180549231\"></p>\n<p>这篇文章使用的是 libc.a，鄙人在使用这个文件时，会生成 pat 文件，但是并不是 pat 文件。也就是说它生成 pat 的文件是错误的 pat 文件，而且它也是使用的 libc.a 文件，说明你需要网上去找（不好寻找，另一种方法是下载此类系统，我想是个聪明人都会觉得这是小题大作了吧。</p>\n<p>由此鄙人寻找另外一种办法去配合 sigmake 文件去生成 sig 文件</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21hbmRpYW50L2ZsYXJlLWlkYS90cmVlL21hc3Rlcg==\">https://github.com/mandiant/flare-ida/tree/master</span></p>\n<p>项目连接在上面</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627181108547.png\" alt=\"image-20240627181108547\"></p>\n<p>使用的 ida 脚本如上，只需要将 libc.so.6 文件拖入 IDA 只用，然后使用 IDA 脚本，就会生成 pat 程序。</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627181227878.png\" alt=\"image-20240627181227878\"></p>\n<p>接下来在使用 sigmake 生成符号表即可</p>\n<p>如果生成 err 文件，我们需要在 exc 删除前面几句话再次执行一次 sigmake 即可</p>\n<h2 id=\"效果演示\"><a class=\"markdownIt-Anchor\" href=\"#效果演示\">#</a> 效果演示</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>gcc <span class=\"token operator\">-</span>s <span class=\"token operator\">-</span><span class=\"token keyword\">static</span> a<span class=\"token punctuation\">.</span>c <span class=\"token operator\">-</span>o test</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"未加符号表之前\"><a class=\"markdownIt-Anchor\" href=\"#未加符号表之前\">#</a> 未加符号表之前</h3>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627181833052.png\" alt=\"image-20240627181833052\"></p>\n<h3 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\">#</a> 过程</h3>\n<h5 id=\"生成pat文件\"><a class=\"markdownIt-Anchor\" href=\"#生成pat文件\">#</a> 生成 pat 文件</h5>\n<p>首先拿到相关程序版本的 libc.so.6 文件，放入 ida 中</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182157239.png\" alt=\"image-20240627182157239\"></p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182240476.png\" alt=\"image-20240627182240476\"></p>\n<h5 id=\"生成sig文件\"><a class=\"markdownIt-Anchor\" href=\"#生成sig文件\">#</a> 生成 sig 文件</h5>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182335363.png\" alt=\"image-20240627182335363\"></p>\n<blockquote>\n<p>./sigmake libc-2.27.pat libc-2.27.sig</p>\n</blockquote>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182446012.png\" alt=\"image-20240627182446012\"></p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182511242.png\" alt=\"image-20240627182511242\"></p>\n<p>删掉所选内容</p>\n<p>再次生成 sigmake 文件</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182556888.png\" alt=\"image-20240627182556888\"></p>\n<p>此时就生成了 sig。</p>\n<h5 id=\"恢复符号表\"><a class=\"markdownIt-Anchor\" href=\"#恢复符号表\">#</a> 恢复符号表</h5>\n<p>将其放进 sig 下的 pc 下</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182712207.png\" alt=\"image-20240627182712207\"></p>\n<p>在要恢复符号的程序下按下 <code>shift + F5</code></p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182830901.png\" alt=\"image-20240627182830901\"></p>\n<p>导入符号表</p>\n<p>双击即可</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182920891.png\" alt=\"image-20240627182920891\"></p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627182950032.png\" alt=\"image-20240627182950032\"></p>\n<p>加符号表之后</p>\n<p><img data-src=\"/img/%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8/image-20240627183127161.png\" alt=\"image-20240627183127161\"></p>\n<p>可见恢复的还是比较多</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3B1c2gwZWJwL3NpZy1kYXRhYmFzZQ==\">https://github.com/push0ebp/sig-database</span></p>\n",
            "tags": [
                "技巧"
            ]
        },
        {
            "id": "https://yhuanhuan01.github.io/2024/05/10/%E5%85%B3%E4%BA%8E%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BF%99%E4%BB%B6%E4%BA%8B/",
            "url": "https://yhuanhuan01.github.io/2024/05/10/%E5%85%B3%E4%BA%8E%E6%81%A2%E5%A4%8D%E7%AC%A6%E5%8F%B7%E8%A1%A8%E8%BF%99%E4%BB%B6%E4%BA%8B/",
            "title": "关于恢复符号表这件事",
            "date_published": "2024-05-10T08:12:12.000Z",
            "content_html": "<p>目标文件：</p>\n<pre><code class=\"language-file\">typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n</code></pre>\n<p>32 位 ARM 架构，静态连接。内核版本 GUN/Linux 2.6.32 | 去符号表</p>\n<blockquote>\n<p>对于修复程序我们首先要准备一个拥有完全符号的程序，使用一些方法给他导出符号表。</p>\n</blockquote>\n<p>因此，我们需要去编译一个与其类似的程序，用 ida 插件 rizzo，去生成其符号表内容</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 文件名: hello_arm.c</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, ARM World!\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>编译内容如下：</p>\n<blockquote>\n<p><code>arm-linux-gnueabihf-gcc -static -march=armv7-a -mfloat-abi=hard -o myapp hello_arm.c</code></p>\n</blockquote>\n<blockquote>\n<p>myapp: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.31, BuildID[sha1]=da2d1220742527123cd7cfeb41bbc4d2facbb3d5, with debug_info, not stripped</p>\n</blockquote>\n<p>接下来我们需要将其用 ida 打开。</p>\n<p><img data-src=\"/img/gccarm/image-20240510152016835.png\" alt=\"image-20240510152016835\"></p>\n<p>点击此处去生成符号表 (.riz)</p>\n<p>接下来就需要再次用 ida 装载我们要恢复符号表的程序。</p>\n<p><img data-src=\"/img/gccarm/image-20240510152245888.png\" alt=\"image-20240510152245888\"></p>\n<p><img data-src=\"/img/gccarm/image-20240510152301219.png\" alt=\"image-20240510152301219\"></p>\n<p>部分函数恢复成功。但是因为两个程序的内核版本不同，或者将 rizzo 识别能力有限的原因。没有恢复的很好，但是确实也是恢复了。</p>\n<blockquote>\n<p>特殊状况：arm 的栈底指针不一定为 R11, 也有可能是其他寄存器。</p>\n<p>​\t\t 因为我自己编出的程序的栈底指针为 R7</p>\n</blockquote>\n",
            "tags": [
                "技巧"
            ]
        }
    ]
}